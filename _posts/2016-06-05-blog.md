---
layout: post
title: C++
category: diary
tagline: ""
tags: [diary]
---
{% include JB/setup %}

# C++

## SFINAE

Substitution Failure Is Not An Error.

テンプレートの置き換えに失敗してもエラーにならないようにする。
Boost の BOOST_FOREACH で、引数が配列かコンテナか判断するのに使われている。


## ラムダ式

### 文法

```c++
int main(int argc, char* argv[]) {
    []  // ラムダキャプチャー
    ()  // パラメータ定義節
    {}  // 複合ステートメント
    ()  // 関数呼び出し式
    ;

    return 0;
}
```

### 例

```c++
#include <iosteram>
int main(int argc, char* argv[]) {
    []{ std::cout << "Hello World" << std::endl; }();
    return 0;
}
```

### 変数へ代入

```c++
#include <iostream>
int main(int argc, char* argv[]) {
    auto func = []{ std::cout << "Hello World" << std::endl; };
    func();
    return 0;
}
```

### 関数へ渡す

```c++
#include <iostream>
template <typename Func>
void f(Func func) {
    func();
}

int main(int argc, char* argv[]) {
    f([]{ std::cout << "Hello World" << std::endl; });
    return 0;
}
```

### 戻り値

```c++
#include <iostream>
int main(int argc, char* argv[]) {
    // 戻り値を省略
    auto a = []() { return 0; }();
    cout << a << endl;
    // 戻り値を明示的に定義
    auto b = []() -> float { return 3.14f; }();
    cout << b << endl;
    return 0;
}
```

### キャプチャ

```c++
#include <iostream>
#include <string>
int main(int argc, char* argv[]) {
    std::string x = "I am string";
    [&] { std::cout << x << std::endl; }(); // 参照
    [=] { std::cout << x << std::endl; }(); // コピー
    return 0;
}
```

#### mutable

コピーの場合、変数を上書きすることは出来ませんが、mutable を使えば変更できます。
ただし、元の変数は変更出来ません。

```c++
#include <iosteram>
#include <string>
int main(int argc, char* argv[]) {
    std::string s = "I am string";
    [=] () mutable { s = "I am string. (overwirte)"; std::cout << s << std::endl; }();
    std::cout << s << std::endl;
    return 0;
}
```


### 参考

http://kaworu.jpn.org/cpp/%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F

```c++
//  配列の長さを拾得する
#define NELEMS(A)				(IzSint32)(sizeof(A)/sizeof(*(A)))

//  値の入れ替え
#define GNU_SWAP(_a, _b)		((_a)^=(_b)^=(_a)^=(_b))

/*----------------------------------------------------------[マクロ]-
  ■ IEEEの32bit float変数専用 高速化目的マクロ
 -------------------------------------------------------------------*/
// Float32をUint32で表現（unsigned integer representation）
#define F32_UIR(_f)					((IzUint32&)(_f))

// Float32をSint32で表現（signed integer representation）
#define F32_SIR(_f)					((IzSint32&)(_f))

// Float32が負か判定（is negative）
#define F32_IS_NEG(_f)				(F32_UIR(_f)&0x80000000)


#define IZ_STATIC_ASSERT(exp)	\
  typedef char	assertion_failed_at_line_##__LINE__[(exp) ? 1 : -1]
```


## 最近の投稿

<ul class="posts">
  {% for post in site.posts %}
    <li><span>{{ post.date | date_to_string }}</span> &raquo; <a href="{{ BASE_PATH }}{{ post.url }}">{{ post.title }}</a></li>
  {% endfor %}
</ul>
